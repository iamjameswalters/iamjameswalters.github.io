<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="generator" content="Pelican" />
  <title>james.walters.click - What Django Deployment is Really About</title>
  <meta name="description" content="Thoughts and lessons learned along the path of software development." />
  <link rel="stylesheet" type="text/css" href="https://james.walters.click/theme/css/pico.min.css" />
  <link rel="stylesheet" type="text/css" href="https://james.walters.click/theme/css/prism.css" />
  <link
    href="https://james.walters.click/feeds/all.atom.xml"
    type="application/atom+xml" rel="alternate" title="james.walters.click Full Atom Feed" />




    <meta name="tags" content="Django" />
    <meta name="tags" content="deployment" />

  <link href="https://james.walters.click/theme/css/fonts.css" rel="stylesheet" type="text/css" />
  <style>
    article img {
      display: block;
      margin-left: auto;
      margin-right: auto;
    }

    #hero {
      align-items: center; 
      margin-bottom: 0;
    }

    @media only screen and (min-width: 481px) { 

      article header {
        display: grid;
      }

      article aside {
        justify-content: end
      }
      
      #hero {
      display: flex; 
    }

    #hero div {
      display: flex;
    }

    #hero img {
      width: 200px;
    }
  }

  @media only screen and (max-width: 480px) { 
    #hero div {
      display: block;
      text-align: center;
    }

    #hero img {
      width: 150px;
      margin-top: 2em;
    }
  }
  </style>
  <script type="text/javascript" src="https://james.walters.click/theme/js/prism.js" defer></script>
</head>

<body>
  <header class="container">
  <nav>
    <ul>
      <li><a href="https://james.walters.click">All Posts</a></li>
    </ul>
    <ul>

        <li><a href="https://james.walters.click/category/linux.html">Linux</a></li>
        <li><a href="https://james.walters.click/category/meta.html">Meta</a></li>
        <li><strong><a href="https://james.walters.click/category/python.html">Python</a></strong></li>
        <li><a href="https://james.walters.click/category/web.html">Web</a></li>
        <li><a href="https://james.walters.click/category/weeknotes.html">Weeknotes</a></li>

    </ul>
  </nav>
  </header>
  <main style="padding-bottom: 0;padding-top: 0;" class="container">
<section id="hero">
  <hgroup style="grid-row: 1;width: 100%; margin-bottom: 0;">
  <h1><a href="https://james.walters.click">james.walters.click</a></h1>
  <h2>Thoughts and lessons learned along the path of software development.</h2>
  </hgroup>

  <div style="grid-row: 1; align-items: center; justify-content: end;">
    <img src="https://www.gravatar.com/avatar/04574f5e4a03ae08ef293b9adc5bc2e3?s=200&d=https%3A%2F%2Fraw.githubusercontent.com%2Fiamjameswalters%2Fpiccolo%2Fmain%2Fpiccolo.png" style="border-radius: 50%;">
  </div>
</section>
<article>
  <header>
    <hgroup>
    <h2>
      <a href="https://james.walters.click/what-django-deployment-is-really-about.html" rel="bookmark"
         title="Permalink to What Django Deployment is Really About">What Django Deployment is Really About</a></h2>
         <h3>By
          <a href="https://james.walters.click/author/james-walters.html">James Walters</a>           on <time class="published" datetime="2023-01-29T00:00:00-05:00">Sun 29 January 2023</time>.</h3>
    </hgroup>
          <aside style="grid-column: 2; display: flex; align-items: end; margin-bottom: 30px;">
           <div style="color: #73828c">Category: <a href="https://james.walters.click/category/python.html">Python</a>          <br />Tags: 
            <a href="https://james.walters.click/tag/django.html">Django</a>,             <a href="https://james.walters.click/tag/deployment.html">deployment</a>        </div>
          </aside>
 
  </header>

  <p>Django has this reputation for being hard to deploy. I don't think that's really true.</p>
<p>I think that people haven't taken the time to explain to beginners the concepts you're thinking about when it comes to deployment. We focus so much on teaching people how to build apps in Django that deployment feels like an afterthought. People are good at making a list of steps, and saying, "Well, here's how <em>I</em> do it." But if that solution isn't suitable because it uses a provider that won't work for you, or because the steps that worked yesterday don't work today, or for one of any number of reasons, then our beginner is stuck without any way to move forward.</p>
<p>I think if we just took the time to explain what the fundamental things are that you're trying to achieve in deployment, it would help beginners get their feet planted and be able to start figuring out each piece of the process, and what works for them in each part.</p>
<p>If you're here looking for deployment steps, you're at the wrong place. But if you'd like to get the lay of the land, an overview of what deployment's really about, then I hope this helps.</p>
<h2>The Penguin in the Room üêßÔ∏è</h2>
<p>Despite the fact that I'm a <a href="https://james.walters.click/tag/linux-grandpa.html">Linux Grandpa</a>, I'm not here to talk about Linux today. I understand a lot of people getting started with Django don't have a lot of familiarity with Linux, and it's a whole new world to get acquainted with, but for the purposes of deployment, it's not so much a concept as it is an implementation detail. </p>
<p>Linux is just an operating system (more accurately, a family of operating systems). It just runs the computer that's going to be serving your site. That may be different than what you're used to, but it's not an entirely new concept. A new concept that's worth considering for deployment would be the idea of skipping the OS layer altogether (<em>ehhhhhhhh,</em> sort of) and deploying with a serverless function. But we're going to count that as outside our purview. If you're capable of considering the pros and cons of going serverless, I think you probably already have a firm grasp of what we're going to get into here. üôÇÔ∏è</p>
<p>I think when it comes to deploying a Django site, you have four overall concerns (and it might be three, depending on what you choose to do):</p>
<ol>
<li>Static Files</li>
<li>Database</li>
<li>WSGI Server</li>
<li>Web Server</li>
</ol>
<p>We'll also mention a couple of minor concerns as we go.</p>
<h2>1. Static Files üìÅÔ∏è</h2>
<p>The first thing that tends to throw beginners for a loop is all of a sudden we start worrying about what to do with static files. What's the deal? I thought Django was handling this for me. <code>{% static %}</code>, right?</p>
<p>Here's what's going on with static files. These are assets like your images, CSS stylesheets, and scripts. They're called "static" files because they aren't dynamically generated. Most of your Django project's pages are built with templates that get filled in with information by your program on demand when users request the page. That never happens with your images or CSS files. They're just files sitting on disk, ready to be served.</p>
<p>Web servers (like <a href="https://httpd.apache.org/">Apache</a> or <a href="https://nginx.org/en/">nginx</a>) were built for the task of taking files on disk and serving them to users. That's where the web started. But we have a Django application because many pages need to be generated on demand with data from the database, we don't have them sitting on disk. A web server can't do that, we need an <em>application</em> to generate those files. </p>
<p>But since these static files aren't generated by your Django app, we don't <em>want</em> Django to handle them. Your Django program is actually way slower than the web server for this job, so we want the web server to do it.</p>
<p>How Django handles that is it stuffs all the static files into one directory (this will be <a href="https://docs.djangoproject.com/en/stable/ref/settings/#static-files">STATIC_ROOT</a> in your <code>settings.py</code>). This makes it easy for the web server to look and find the files it needs to serve. Then, we use <code>{% static %}</code> in our templates to tell Django that the request for this file needs to be passed along directly to the web server.</p>
<p>Now, the reason all this might seem kind of new is because Django <em>has</em> been handling static files for you in development. The Django development server (<code>manage.py runserver</code>) has to handle those requests, because when you're developing locally it's the <em>only</em> web server available. But when you deploy, you'll have to use a better web server than that, and that server will be quite capable of handling static files on its own.</p>
<p>Configuring a web server to handle static file requests is beyond the scope of this post, but here's a <a href="https://realpython.com/django-nginx-gunicorn/#serving-static-files-directly-with-nginx">helpful guide</a> on the topic. Give it a try! I was pleasantly surprised at how straightforward it was to write an nginx configuration file.</p>
<p>Once you've set a <code>STATIC_ROOT</code> to stuff your static files in, you can actually stuff them there by running <code>manage.py collectstatic</code>. You'll have to do this anytime you change any of your static files.</p>
<h3>Whitenoise</h3>
<p>It might be the case that for whatever reason you don't have access to be able to configure the web server for your site. In that case, your best option might be to use a tool called <a href="https://pypi.org/project/whitenoise/">Whitenoise</a>. This is a middleware that you can use in your Django app. If you don't know this, a Django request passes through all the different middlewares (listed in <code>settings.py</code>), and they each get their turn to do something. The Whitenoise middleware checks to see if the request is for a static file, and if so, it interrupts the rest of the request cycle (which would be slow) and immediately serves up the static file.</p>
<p>You might also opt for this option if you're lazy. But don't&mdash;it still isn't as fast as a web server handling this directly, and configuring nginx really isn't that hard. If you're a web developer, you should understand the tools used to run your code. </p>
<h3>Media Files</h3>
<p>It's worth mentioning that the same concerns apply to user-uploaded content, what Django calls "media files". If you have a site where users can e.g. upload a profile picture, you'll want to <a href="https://docs.djangoproject.com/en/stable/howto/deployment/checklist/#media-root-and-media-url">configure these</a> as well.</p>
<h2>2. Database üíæÔ∏è</h2>
<p>The next thing that you'll have to pay some thought to in deployment is your database situation. </p>
<p>In development, you've been using a local SQLite file. SQLite is really nifty, because it keeps everything in one single file. Since you don't "connect" to it, you don't have to handle connection details. Your <code>DATABASE</code> section in <code>settings.py</code> is pretty simple. </p>
<p>In deployment, SQLite may not be suitable (though it's <a href="https://fly.io/blog/sqlite-internals-wal/">more capable than you're often led to believe</a>). Generally if you're using some sort of cloud provider, you'll be connecting to a database that's managed for you. This isn't usually different for your app in any material way (though <a href="https://docs.djangoproject.com/en/stable/ref/databases/">databases differ</a> in both features and limitations), but it is a rather important detail of deployment you need to be aware of.</p>
<p>The important difference will be that you'll need to configure connection details in your <code>settings.py</code>. This will mean adding a host address, port, username and password. It'll wind up looking something like this example from the <a href="https://docs.djangoproject.com/en/stable/ref/settings/#databases">Django docs</a>:</p>
<div class="highlight"><pre><span></span><code><span class="n">DATABASES</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;default&#39;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s1">&#39;ENGINE&#39;</span><span class="p">:</span> <span class="s1">&#39;django.db.backends.postgresql&#39;</span><span class="p">,</span>
        <span class="s1">&#39;NAME&#39;</span><span class="p">:</span> <span class="s1">&#39;mydatabase&#39;</span><span class="p">,</span>
        <span class="s1">&#39;USER&#39;</span><span class="p">:</span> <span class="s1">&#39;mydatabaseuser&#39;</span><span class="p">,</span>
        <span class="s1">&#39;PASSWORD&#39;</span><span class="p">:</span> <span class="s1">&#39;mypassword&#39;</span><span class="p">,</span>
        <span class="s1">&#39;HOST&#39;</span><span class="p">:</span> <span class="s1">&#39;127.0.0.1&#39;</span><span class="p">,</span>
        <span class="s1">&#39;PORT&#39;</span><span class="p">:</span> <span class="s1">&#39;5432&#39;</span><span class="p">,</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>Note the plaintext user and password&mdash;we'll return to this topic later.</p>
<p>Once you've got your deployment database set up, you'll want to run <code>manage.py migrate</code> to set it up for the first time, just like you did way back at the beginning of your project to set up SQLite. From that point onward, you should be good to go.</p>
<h2>3. WSGI Server ü•ÉÔ∏è</h2>
<p>Now we get to an important lesson in understanding how your Django app <em>actually runs.</em></p>
<p>In development, you've been using <code>manage.py</code> to run your app. But as the name would suggest, <code>manage.py</code> is just a management script. How do we run our Django app in a production environment?</p>
<p>You'll recall that we talked about having a web server (like nginx) installed. This is the piece of software that receives HTTP requests and returns HTTP responses. Web servers are great at serving files off of the computer's disk. But we have Django apps (or PHP apps, or web apps written in any other language or framework) to generate web pages on demand. So we have a web server that accepts requests and returns responses, and we have a web application that is capable of generating pages on demand.</p>
<p>How do we get these two things to work together though? The web server just handles files, how do we make it talk to another application?</p>
<p>In older days, a standard was defined called <a href="https://en.wikipedia.org/wiki/Common_Gateway_Interface">CGI</a> (or Common Gateway Interface). Basically, the way it worked was when a web server received a request that needed to be handled by the web application, it would call a CGI script (these are usually written in Perl) and pass information about the request as arguments over <a href="https://en.wikipedia.org/wiki/Standard_streams#Standard_input_(stdin)">standard input</a>. That script could the call the web application the way it needed to be called and pass it the appropriate info.</p>
<p>In Python land, we have a similar standard called <a href="https://en.wikipedia.org/wiki/Web_Server_Gateway_Interface">WSGI</a> (or Web Server Gateway Interface). It's usually pronounced <em>whizz-ghee.</em> The way this works is the web server passes the request over to a WSGI server (like <a href="https://pypi.org/project/gunicorn/">gunicorn</a> or <a href="https://pypi.org/project/waitress/">Waitress</a>). That WSGI server runs a WSGI callable for your application. How on earth do I make that, you ask? Django already did it for you when you ran <code>startproject</code>&mdash;it's in the <code>wsgi.py</code> file. </p>
<p>So, you need to install a WSGI server, and pass it your <code>wsgi.py</code> file to run. If you're setting up a virtual machine, you might write a script to run this on boot, or use a <a href="https://vsupalov.com/django-systemd-crashcourse/">systemd service</a>. Then, you <a href="https://realpython.com/django-nginx-gunicorn/#incorporating-nginx">configure the web server</a> to pass requests over to the WSGI server. The WSGI server will run it through your Django app, and after generating the appropriate page, pass that response back to the web server to hand off to your user.</p>
<h3>ASGI</h3>
<p>You might also hear about <a href="https://en.wikipedia.org/wiki/Asynchronous_Server_Gateway_Interface">ASGI</a> (azzz-ghee), or the <em>asynchronous</em> server gateway interface. As asynchronicity becomes easier and more popular in Python and other programming languages, web frameworks are looking to leverage that. Someday soon, this'll become the standard way to run your web app. As far as I understand, it's designed to be pretty similar to WSGI, just asynchronous. As far as your Django deployments go, it'll probably just mean you use <code>asgi.py</code> instead of <code>wsgi.py</code>.</p>
<h2>4. Web Server üï∏Ô∏è</h2>
<p>We've already talked about it a bit, but the last big deployment concern is setting up the web server which will be standing in front of your Django app.</p>
<p>As we alluded to earlier, <a href="https://httpd.apache.org/">Apache</a> and <a href="https://nginx.org/en/">nginx</a> are going to be your two main options. Configuring either of them is beyond our scope here. If you don't know which to choose, nginx tends to be more popular these days, on account of how it handles requests within threads (it tends to be more efficient, and thus faster). Apache's a venerable old warhorse though, and it's a perfectly acceptable option. It ran much of the internet of the last two decades or more.</p>
<p>Depending on how you choose to deploy though, you might not need to worry about your web server at all. There are a number of routes to go, but most of the time you'll be looking at either a virtual machine (VM/VPS) or platform-as-a-service (PaaS). </p>
<p>A virtual machine (or virtual private server) is basically a rented computer. You can get these from providers like <a href="https://www.linode.com/lp/refer/?r=a4d4d262b7f9176323aa169ee6a142978b235dda">Linode</a> (disclaimer: this is a referral link) for as little as $5 a month. This is basically a Linux server that you can SSH into. It'll be a very manual setup process, with little handholding. But, you'll understand every step of the way. If you go this route, you'll be responsible for everything about the server: restarting it if it goes down, tracking and rotating log files, managing security settings and updates, etc.</p>
<p>A platform-as-a-service is kind of different. Basically, the provider will abstract away the underlying computer, and you just focus on your app. You get your code uploaded, provide some details about hooking up a database, static files, where the script to execute is, etc., and you don't have to worry about the server-y stuff like worrying about updates, checking logs, or understanding security settings. You also wouldn't have to configure a web server, the provider would handle that for you. You mostly likely wouldn't even know which web server they're using under the hood. PaaS usually costs a little bit more than a $5 VPS, but if you don't want to become a part-time system administrator, then it's easily worth it.</p>
<p>Heroku is the original platform-as-a-service provider, but they've been in a bit of hot water lately for ending their free tier. I personally don't like it because I think it obfuscates and papers over the issues that I've covered here. <a href="https://testdriven.io/blog/heroku-alternatives/">Other options abound</a>. I use a PaaS provider called <a href="https://www.pythonanywhere.com/">PythonAnywhere</a>. I think they've done a good job at keeping the control panels focused on the details we're talking about in this post. They also have a free tier for those just getting started.</p>
<h2>Getting Code onto the Thing üì¶Ô∏è</h2>
<p>There's a couple of other minor concerns aside from what we've already mentioned, one of which is how you actually get your code onto the thing you're deploying to. There's a lot of flexibility here. In the old days, it would have been <code>rsync</code>ing the folder from your computer to the server. These days, since most developers are using <code>git</code>, they just run <code>git clone</code> on the server to pull down the repository (then, you can <code>git pull</code> anytime you make changes to your program). Your provider might even offer you a point-and-click file manager (PythonAnywhere does) and you can just manually upload your code folder that way.</p>
<p>There's a number of ways to do it, none of which are very hard. </p>
<h2>Secrets üîíÔ∏è</h2>
<p>The last thing we should mention is handling secrets. You'll remember earlier in our database config our example had the user and password stored right there in <code>settings.py</code>. We don't really want to keep sensitive info like that in code, because we don't want it to be commited to version control, like <code>git</code>. Even if you have something like a private Github repository, there's a risk of someone getting access to your code. Once you've committed a password to <code>git</code>, it's basically impossible (not <em>technically,</em> but it's extremely difficult, and even then it might be too late) to get it out of your repository's commit history. It's better to handle secrets another way.</p>
<p>There are two primary schools of thought on this. The older convention for doing this would be to have two <code>settings.py</code> files, one for development and one for deployment, which is <strong>never</strong> committed to version control. The way people tend to do this these days is with environment variables, which are pieces of data that are stored in the runtime environment of the computer running your code. </p>
<p>There are a few ways to get at environment variables from within a Python script. Personally, I find the <a href="https://pypi.org/project/python-decouple/">python-decouple</a> package straightforward and easy to use. It allows me to store database credentials and my <a href="https://docs.djangoproject.com/en/stable/ref/settings/#secret-key">SECRET_KEY</a> in a file called <code>.env</code> (which, again, should <strong>never</strong> be commited to version control). Then, I can get at those values with <code>decouple.config()</code>. Options abound though, and find whatever's right for you. Just make sure your secrets aren't committed to code.</p>
<h2>Django's Deployment Checklist ‚úÖÔ∏è</h2>
<p>It's worth mentioning that Django has it's own built-in <a href="https://docs.djangoproject.com/en/stable/howto/deployment/checklist/">deployment checklist</a> to help you think through some of the things involved in deployment. To use it, just run <code>manage.py check --deploy</code>, and you'll get feedback on anything that needs attention.</p>
<h2>django-simple-deploy</h2>
<p>Eric Matthes has a wonderful project going called <a href="https://django-simple-deploy.readthedocs.io/en/latest/">django-simple-deploy</a>, which aims to be a utility that you can run against your code, and it will automatically handle all the steps needed to get your code deployed. The idea is not to abstract away the deployment process, but to be something that helps a newcomer get their code online, then they can compare the changes it made to their code settings and learn how exactly it went about it. As of writing, it supports deploying to Fly.io, Platform.sh, and Heroku. More platforms should be on the way.</p>
<h2>Wrapping Up üéÅÔ∏è</h2>
<p>There's a lot of other things we could talk about. Should you containerize your app with Docker? Should you deploy with a serverless function? Which database is the best database? These are all good next steps to consider. </p>
<p>At bare minimum, I hope I've shown that these four major concerns (static files, database, WSGI server, and web server) are the places to begin when figuring out how to deploy your Django application. If you can get your head wrapped around these things, you'll be able to get your app online and make it to "Hello World". The rest are details that you'll pick up as you continue to develop and get comfortable putting your work online.</p>
<footer style="font-weight: bold; text-align: center;">
Found this helpful? <a href="https://ko-fi.com/iamjameswalters">Buy me a coffee!</a> ‚òïÔ∏è
</footer>

  </article>
  </main>
  <footer style="display: grid; grid-template-columns: repeat(auto-fit, [col-start] minmax(100px, 1fr) [col-end]); padding-top: 0;" class="container">
    <aside style="grid-row: 1;">
    <nav>
      <ul>
        <li><strong>Social:</strong></li>
      </ul>
      <ul>
      <li><a href="http://github.com/iamjameswalters" rel="me">Github</a></li>
      <li><a href="https://fosstodon.org/@jameswalters" rel="me">Mastodon</a></li>
      <li><a href="https://ko-fi.com/iamjameswalters" rel="me">By me a coffee (Ko-Fi)</a></li>
      <li><a href="mailto:iamjameswalters@gmail.com" rel="me">iamjameswalters@gmail.com</a></li>
      </ul>
    </nav>
    </aside>
    <aside style="grid-row: 1;">
    <nav>
      <ul>
        <li><strong>Links:</strong></li>
      </ul>
      <ul>
      <li><a href="https://hypermedia.systems/">Hypermedia Systems</a></li>
      <li><a href="https://grugbrain.dev/">The Grug Brained Developer</a></li>
      <li><a href="https://adamj.eu/tech">Adam Johnson's Blog</a></li>
      </ul>
    </nav>
    </aside>

    <aside style="grid-row: 1;">
    <nav>
      <ul>
        <li><strong>Feeds:</strong></li>
      </ul>
      <ul>
        <li><a href="https://james.walters.click/feeds/all.atom.xml" type="application/atom+xml" rel="alternate">Atom feed</a></li>
      </ul>
    </nav>
    </aside>

    <div style="grid-row: 2; grid-column: span 3;">
      <hr />
      <p style="padding-top: 0.5em;">
      Built using the <a href="https://github.com/iamjameswalters/piccolo">Piccolo</a> theme, based on <a href="https://picocss.com/">Pico.css</a>.</p>
    </div>
  </footer>
</body>

</html>